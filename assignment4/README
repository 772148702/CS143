user:songhan
user:xuany

README file for Programming Assignment 4  (C++ edition)
=======================================================

===============================================================================
    1 Code Generation for Global Constants and Tables
===============================================================================

-------------------------------------------------------------------------------
        1.1 CgenClassTable Structures
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
        1.2 Code Generation for Object Init methods
-------------------------------------------------------------------------------




===============================================================================
    2 Environment Design in Code Generation
===============================================================================

As pointed out in lecture, there are three contexts need for operational semantics:
1). Environment: map from variable names to locations
2). Store: map memory locations to values
3). self object

In our implementation, the Environment is implented in the data structure of Environment:
  int label_cnt;                        // the label counter
  class__class* cur_class;              // the current class
  CgenClassTable* cgen_table;           // the table contains all the class nodes
  SymbolTable<Symbol, char> sym_table;  // this is the mapping of variables to memory locations
  
There are several cases when a new variable is introduced, and they should be added
to the environment:
1). attributes in class
2). formals in method
3). typecases
4). let


===============================================================================
    3 Code Generation Details
===============================================================================

----------------------------------
       3.1 Stack Machine Model 
----------------------------------
We used the statck machine model to implement the code generator. Whenever a new
variable is newed or and expression is evaluated, the return value (as an object
pointer) is always stored in $a0 and pushed to stack. Before and after evaluating
each expression, it is guranteed that the state of the stack remain unchanged. 


The invariants used in our implementation are:
    - $fp always point to "position 0" of current frame
    - $s0 always hold "self object"
    - $ra always hold return address
    - $a0 always hold evaluation result
    - stack state is the same before and after evaluation of any expression


-----------------------------------
       3.2 Dispatch and Method
-----------------------------------   

When generating code for dispatch, we first code for all the actuals, and push
them to stack one by one. At this point, the stack pointer went from (0) to (1).
Then the body expression is coded and the return object pointer is stored in $a0. Then, the 
class name of e0 is derived. If it's dynamic dispatch, the dispatch table could
be directly obtained by offset of 8 from $a0; If it's static dispatch, the dispatch
table's address should be derived by loading the address the static class's dispatch
table. The next step is to get the offset of the method from the dispatch table
and jump to that method. 

           ------------
          |    Arg1    |    (0, 3)     High Address
           ------------
          |    Arg2    |
           ------------
                :
           ------------
          |    ArgN    |    (1)
           ------------
          |  old $fp   |
           ------------
          |  old $s0   |
           ------------
  FP ->   |    $ra     |    
           ------------
  SP ->   |            |    (2)      Low Address
           ------------
           
Whem generating code for method, first update the "Environment" i.e. the location
of each variable introduced by formals. Then push the callee saved registers: $fp,
$s0 and $ra, and update the frame pointer. Now the stack pointer is at (2). Having
these preparations, we could code the body of the method. Finally, we pop the stack
(including all the arguments) and recover the saved registers. Then the stack frame
shall recover to the original location (3)


----------------------------------
        3.2 Let Expression
----------------------------------


----------------------------------
        3.3 Case Expression
----------------------------------


===============================================================================
    4 Error Checking and Handling
===============================================================================


----------------------------------
        4.1 dispatch on void
----------------------------------


----------------------------------
        4.2 case on void
----------------------------------


----------------------------------
        4.3 missing branch
----------------------------------





