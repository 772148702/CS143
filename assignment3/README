README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile		-> [course dir]/assignments/PA3/Makefile
 README
 ast-lex.cc		-> [course dir]/src/PA3/ast-lex.cc
 ast-parse.cc		-> [course dir]/src/PA3/ast-parse.cc
 bad.cl
 cgen			-> [course dir]/etc/../lib/.i
 cool-tree.cc		-> [course dir]/src/PA3/cool-tree.cc
 cool-tree.h
 cool-tree.handcode.h
 dumptype.cc		-> [course dir]/src/PA3/dumptype.cc
 good.cl
 handle_flags.cc	-> [course dir]/src/PA3/handle_flags.cc
 mycoolc		-> [course dir]/src/PA3/mycoolc
 mysemant		-> [course dir]/src/PA3/mysemant
 semant-phase.cc	-> [course dir]/src/PA3/semant-phase.cc
 semant.cc
 semant.h
 stringtab.cc		-> [course dir]/src/PA3/stringtab.cc
 symtab_example.cc	-> [course dir]/src/PA3/symtab_example.cc
 tree.cc		-> [course dir]/src/PA3/tree.cc
 utilities.cc		-> [course dir]/src/PA3/utilities.cc
 *.d			  dependency files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code.  Just edit this file.

	good.cl and bad.cl test a few features of the semantic checker.
	You should add tests to ensure that good.cl exercises as many
	legal semantic combinations as possible and that bad.cl
	exercises as many kinds of semantic errors as possible.

	semant.h contains declarations and definitions for the semantic
	analyzer.  Place class definitions for the structures you will
	use here.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.  DO
        NOT MODIFY.

        cool-tree.h, and cool-tree.handcode.h specify and give an
        implementation of Cool ASTs (see the README for PA3 and the
        "Cool Tour").  In this assignment, you will need to add
        functions to the AST classes to store, fetch, and compute
        information about the AST.  Note that cool-tree.handcode.h
        differs slightly from the file supplied for PA3.

   	You should NOT remove any definitions that are already present
	in cool-tree.h and cool-tree.handcode.h.  These functions and
	data members are required for the system to function properly.

        You should add any fields and methods to the classes you need to 
	perform semantic analysis.  You	will need to add, for example, 
	methods which traverse the expressions of the tree and implement 
	the type-checking rules.

	cool-tree.cc contains definitions of the provided methods,
	and instantiations of the template for the list handling functions.
	You should not modify this file, but place definitions of all
	methods you add to cool-tree.h or cool-tree.handcode.h in semant.cc.
	DO NOT MODIFY cool-tree.cc

	semant.cc is the file in which you should write your semantic
	analyzer.  The main() procedure calls the method `semant'
	on `ast_root', the root of the abstract syntax tree generated by
	the parser.  There are methods supplied that you should use to report 
	errors. You are relatively free in how you decide to structure the 
	semantic checker, but don't modify the error printing routines.

	ast-lex.cc and ast-parse.cc implement a lexer and a parser for
	reading text representation of ASTs from console in the format
	produced by the parser phase. DO NOT MODIFY.

	semant-phase.cc contains a test driver for semantic analysis.
	The main program reads an AST in text form from standard input,
	parses it, and then produces a type-annotated AST on standard
	output.  The script mycoolc can pass any of the standard flags
	to the semantic analyzer as well; for this assignment, -s
	(semantic analysis debug) may be useful as it sets a global
	variable semant_debug to true (1).  If you want your semantic
	checker to print debug information when the option is set, write
	your debug code in the following format:

	      if (semant_debug)
	      {
		...
	      }

	semant_debug is provided as a convenience. You don't need to use
	the debugging flags if you don't want to. DON'T MODIFY
	semant-phase.cc

	symtab.h contains a symbol table implementation. Read the
	comments in the file, the "Cool Tour", and look at the example
	in symtab_example.cc.  You are not required to use this code,
	but you may find it useful. DO NOT MODIFY.

Instructions
------------

	To compile the example use of the symbol table, type

	% make symtab_example
        % ./symtab_example

	To compile your semantic analyzer program type:

	% make semant

	To test your semantic checker, type:

        % ./mysemant good.cl

	mysemant is a version of mycoolc that omits code generation.
	mysemant parses all the cool files given on the command line and
	builds a single abstract syntax tree containing all class
	definitions appearing in the input files. Your semantic checker
	is then called on this abstract syntax tree.  If there are no
	errors, the program produces a type-annotated abstract syntax
	tree as output.

	To run your checker on the files good.cl and bad.cl type:

	% make dotest

	If you think your semantic checker is correct and behaves like
	the one we wrote, you can try to run mycoolc using your checker,
	your parser and also your lexical analyzer if you choose (see
	below for instructions).  Remember if your lexer, parser or
	checker behaves in an unexpected manner, you may get errors
	anywhere.

	To turnin your work type:

	% make submit-clean

	And run the "submit" program following the instructions on the
	course web page.
	
	Running "submit" will collect the files semant.cc, semant.h,
	cool-tree.h, good.cl, bad.cl, good.output, bad.output, and
	README. Don't forget to edit the README file to include your
	write-up, and to write your own test cases in good.cl and
	bad.cl.  

 	You may turn in the assignment as many times as you like.
 	However, only the last version will be retained for grading.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

*************************************************************************
                   Scope checking and type checking
*************************************************************************

3.1 AST traversal 
----------------------------
We used the visitor pattern to write the program during the AST traversal. 

The visitor pattern seperates operations on objects and objects' 
representation. Therefore we implemented seperate visitor for each operation.

The traversal interface has two kinds of checking:
  - scope-checking visitor 
  - type-checking visitor
  
To implement various visitor to differnt kinds of class, we first implement
an interface class Visitor, and defined a bunch of virtual visit function in it:

class Visitor {
public:
	virtual void visit(Program e)=0;
	virtual void visit(Class_ e)=0;
	virtual void visit(Feature e)=0;
	virtual void visit(Formal)=0;
	virtual void visit(Expression e)=0;
	virtual void visit(Case e)=0;

	virtual void visit(program_class *e)=0;
	virtual void visit(class__class *e)=0; 
	...
}

Then we inherit from the interface Vistor and got a semanVisitor to build the frame of 
our semantic analyzer.

According to the "dragon book", visitor pattern does not requires frequent type casts 
nor frequent recompilation. The code structure is basically like this:

class semanVisitor: public Visitor {
public:
	SymbolTable<Symbol, tree_node> *symtable_o;
	SymbolTable<Symbol, tree_node> *symtable_m;
	
    void addId(Symbol s, tree_node *i, bool is_method) 
   {  
      if(is_method)  symtable_m->addid(s, i);
      else  symtable_o->addid(s,i);
   }

  tree_node * probeMethod(Symbol s) {return symtable_m->probe(s);}
  tree_node * probeObject(Symbol s) {return symtable_o->probe(s);}
  tree_node * lookupMethod(Symbol s) {return symtable_m->lookup(s);}
  tree_node * lookupObject(Symbol s) {return symtable_o->lookup(s);}
	...
	
private:
	class__class* currentClass;	
}

Here, symtable_o is the symbol table for object, and symtable_m is the symbol table 
for method. When we find an item with its scope, we will use addID function to add it 
to the corresponding symbol table for later probe or look up. 
	  

3.2 Scope checking
----------------------------
The hierachy of a Cool program can be described as four levels -- program,
class, feature, and expression. When traversing between these levels, we 
enter a new scope and later exits the current scope. Therefore in each 
subClass of TreeNode, we define the following function:

public void  accept(Visitor *v){
	v.enterscope();
	v.visit(this);
	v.exitscope();
} 

Because it will not casue conflict when method and attribute share the same name, 
so we implement two Symbol Tables to store methods and objects(attributes, formals, 
lets, branches) respectively. 

When a program/class/feature is visited, semanVisitor scans the definition
and generate a member list. When checking the scope of a class, we also need to analyze
its parent. Because it is illegal to have current class and parent class's attributes
share the same name. To avoid this happening, we collect the list of parent 
members and those of the current class, then compare with each other. Then when the 
comparison is over, we can add them to the current scope for the scope checking of 
its features.

3.3 type checking 
----------------------------						 
When doing type checking, the types are computed up the AST from the leaves towards the root,
but the type environment is passed down the AST from the root towards the leaves, including
method information, identifier scope information. As a result, we merge type checking
and scope checking in one pass, taking good advantage of the symbol table.

For the environment structure, we have 3 differnt environment information that
needs to keep track of. Therefore, we use a) two symbol tables, one for method, 
and one for object. b) currentClass indicating the current processing class 
c) a 2-level map, the key for the first level is the class name, and that for 
the second level is the method name, and the value stored is a list containing
all relevant types in method signature.

Symbol tables and currentClass are maintained as private members in visitor, since they
will change with the visiting process; while map is created and stored in
ClassTable, since its containing information is global and static.


