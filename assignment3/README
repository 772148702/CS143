user:xuany
user:songhan

Write-up for PA3

*****************************************************************************
                  1. Inheritance Graph
*****************************************************************************
----------------------------
    1.1 Data Structure 
----------------------------
1). A map from class name to class. The key is a symbol name. This map is used
   for searching a class object from a its name.
   std::map<Symbol, class__class*> class_map;
   
2). Inheritance map. This is also a map: the key is the class name, and the 
   value is a set of all the child class name.
   std::map<Symbol, std::set<Symbol> > inherit_graph;
   
The public methods for the class table are:
  bool class_exist(Symbol );
  bool method_exist(Symbol , Symbol );
  bool is_child (Symbol , Symbol );
  Symbol least_upper_bound(Symbol , Symbol );
  class__class * get_parent( Symbol  );
  method_class* get_method ( Symbol , Symbol );
  std::vector<Symbol> get_signature(Symbol , Symbol );
  void verify_signature( class__class* , method_class* ); 

----------------------------
    1.2 Install classes
---------------------------- 
The first step of the class table constructor is to install the basic classes
and the user classes, i.e. to populate the class_map and the inheritance_map.
During the insertion the following properties are checked:
Defining:
1. Whether a class was redefined.
2. Whether a basis class is redefined.
3. Whether main class exist.
Inheriting:
1. Whether a class is inheriting from Int, Str, IO, SELF_TYPE.
2. Whether the parent exists.

----------------------------
    1.3 Check Cycles
---------------------------- 
The main algorithm for cycle check is DFS and colouring. Now we have the adjacency
set representation of the class map. The next thing to check is cycle. We iterate
through all the nodes as the start node, calling the private method DFS_has_cycle.
In this depth first search, each node has three possible states:

 0: representing it has not been visited before
-1: representing it has been visited but not all of its children have been
    visited. 
 1: representing all of its children has been visited before. 

When a -1 state node is visited twice, then it means there's a cycle in the 
graph.  
----------------------------
    1.4 Is child
---------------------------- 
is_child(c,p) checks if c is a child of p. This is a useful public method for later
checks. The implementation is also based on DFS: to search from parent node p to see
if there's path from p to c

----------------------------
    1.5 Least upper bound
---------------------------- 
least_upper_bound (c1, c2) returns the least upper bound class of c1 and c2. This
shall be used when determining the common type for if then else etc. The algorithm 
is to start from the Object class and iterate down all of its children, to check if
any of them is still a parent of the target. This is assisted by is_child method.
    

*****************************************************************************
                  2. Method Map
*****************************************************************************    
To set up the environment, we need object environment, class environment, and
method environment. The former two are implemented by the symbol table and the
class table already, now we need a data structure to represent the method 
environment.
----------------------------
    2.1 Data Structure 
----------------------------
map from class name and function name to function
  std::map<Symbol, std::map<Symbol, method_class*> > method_map;

    
    
    
*****************************************************************************
                  3. Scope checking and type checking
*****************************************************************************
----------------------------
    3.1 AST traversal 
----------------------------
We used the visitor pattern to write the program during the AST traversal. 

The visitor pattern separates operations on objects and objects' 
representation. Therefore we implemented separate visitor for each operation.

The traversal interface has two kinds of checking:
  - scope-checking visitor 
  - type-checking visitor
  
To implement various visitor to different kinds of class, we first implement
an interface class Visitor, and defined a bunch of virtual visit function in it:

class Visitor {
public:
	virtual void visit(Program e)=0;
	virtual void visit(Class_ e)=0;
	virtual void visit(Feature e)=0;
	virtual void visit(Formal)=0;
	virtual void visit(Expression e)=0;
	virtual void visit(Case e)=0;

	virtual void visit(program_class *e)=0;
	virtual void visit(class__class *e)=0; 
	...
}

Then we inherit from the interface Visitor and got a semanVisitor to build the frame of 
our semantic analyser. The code structure is basically like this:

class semanVisitor: public Visitor {
public:
	SymbolTable<Symbol, tree_node> *symtable_o;
	SymbolTable<Symbol, tree_node> *symtable_m;
	
    void addId(Symbol s, tree_node *i, bool is_method) 
   {  
      if(is_method)  symtable_m->addid(s, i);
      else  symtable_o->addid(s,i);
   }

  tree_node * probeMethod(Symbol s) {return symtable_m->probe(s);}
  tree_node * probeObject(Symbol s) {return symtable_o->probe(s);}
  tree_node * lookupMethod(Symbol s) {return symtable_m->lookup(s);}
  tree_node * lookupObject(Symbol s) {return symtable_o->lookup(s);}
	...
	
private:
	class__class* currentClass;	
}

Here, symtable_o is the symbol table for object, and symtable_m is the symbol table 
for method. When we find an item with its scope, we will use addID function to add it 
to the corresponding symbol table for later probe or look up. 
	  
----------------------------
  3.2 Scope checking
----------------------------
The hierarchy of a Cool program can be described as four levels -- program,
class, feature, and expression. When traversing between these levels, we 
enter a new scope and later exits the current scope. Therefore in each 
subClass of TreeNode, we define the following function:

public void  accept(Visitor *v){
	v.enterscope();
	v.visit(this);
	v.exitscope();
} 

Because it will not cause conflict when method and attribute share the same name, 
so we implement two Symbol Tables to store methods and objects(attributes, formals, 
lets, branches) respectively. 

When a program/class/feature is visited, semanVisitor scans the definition
and generate a member list. When checking the scope of a class, we also need to analyse
its parent. Because it is illegal to have current class and parent class's attributes
share the same name. To avoid this happening, we collect the list of parent 
members and those of the current class, then compare with each other. Then when the 
comparison is over, we can add them to the current scope for the scope checking of 
its features.

----------------------------	
  3.3 type checking 
----------------------------						 
When doing type checking, the types are computed up the AST from the leaves towards the root,
but the type environment is passed down the AST from the root towards the leaves, including
method information, identifier scope information. As a result, we merge type checking
and scope checking in one pass, taking good advantage of the symbol table.

For the environment structure, we have 3 different environment information that
needs to keep track of. Therefore, we use a) two symbol tables, one for method, 
and one for object. b) currentClass indicating the current processing class 
c) a 2-level map, the key for the first level is the class name, and that for 
the second level is the method name, and the value stored is a list containing
all relevant types in method signature.

Symbol tables and currentClass are maintained as private members in visitor, since they
will change with the visiting process; while map is created and stored in
ClassTable, since its containing information is global and static.

The next procedure is to do type checking and scope checking in one pass.
Combined with the global information on class and methods from 
ClassTable and method table, we have all the information needed to perform type checking.
Whenever we call visit() on a particular expression, scope checking has already 
done around this expression, and we can get all relevant object information in the 
symbol table.  

Most of the type checking is the translation of the cool manual into code. Take 
static dispatch for example, 
e0@T.f(e1, e2,..., en): Tn+1  
We first get e0 type, it should be subtype of T. Then we call method f in class 
T. We can get the signature of the method from method map. Then we 
check whether the type of the method is the subtype of the signature. If return 
type in signature is SELF_TYPE, we return the current Class type. Otherwise, 
we return the signature's type. 
 
We also need check whether it is legal to call methods and attributes before definition.
This is legal for classes, methods and attributes. 
Classes are already recorded in ClassTable, what we left to do is check. Also we can get the 
name and signature of the method and attributes in the install_user_class.
 
The tricky part in type checking is dealing with SELF_TYPE. The least upper
bound of SELF_TYPE is SELF_TYPE, and this fact is used in IF and CASE
expressions; also, whenever type compatibility is checked, we have to translate
SELF_TYPE before hand.
 
For self, we need to compare every ID in the Cool Syntax. We need to make sure that 
no object name is "self".
 
For the SELF_TYPE, we check all the places with TYPE in Cool Syntax. For example, in 
	m(x:T):T' {...}
only T' can be SELF_TYPE (T cannot be SELF_TYPE). In fact, we follow exactly as what cool 
manual says in terms of type checking. 

*****************************************************************************************
                                  Error Handling
*****************************************************************************************
We have fatal errors and nomal errors to handle. Fatal errors mainly happen in these cases:
a) inherit from basic class
b) inherit from SELF_TYPE 
c) inherit from non-existing class
d) class redefinaton (including basic class)
e) cycle found in inheritance graph

For the 
